<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>OMN Composer Workbench v2</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Courier+Prime:ital,wght@0,400;0,700;1,400&family=Bebas+Neue&family=DM+Serif+Display:ital@0;1&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg: #111317;
        --bg2: #191c21;
        --bg3: #22262d;
        --border: #323842;
        --accent: #5ccbb6;
        --accent2: #b58fda;
        --accent3: #58a6ff;
        --on: #5ccbb6;
        --rest: #151f25;
        --rest-border: #213540;
        --text: #e1e7ef;
        --text-dim: #8b949e;
        --danger: #ff7b72;
        --green: #56d364;
        --mono: "Courier Prime", monospace;
        --display: "Bebas Neue", sans-serif;
      }
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        background: var(--bg);
        color: var(--text);
        font-family: var(--mono);
        min-height: 100vh;
        overflow-x: hidden;
      }
      body::before {
        content: "";
        position: fixed;
        inset: 0;
        background-image: repeating-linear-gradient(
          0deg,
          transparent,
          transparent 28px,
          rgba(92, 203, 182, 0.03) 28px,
          rgba(92, 203, 182, 0.03) 29px
        );
        pointer-events: none;
        z-index: 0;
      }
      .app {
        position: relative;
        z-index: 1;
        max-width: 1240px;
        margin: 0 auto;
        padding: 20px;
      }
      header {
        display: flex;
        align-items: baseline;
        gap: 20px;
        margin-bottom: 24px;
        border-bottom: 1px solid var(--accent);
        padding-bottom: 10px;
      }
      header h1 {
        font-family: var(--display);
        font-size: 2.2rem;
        letter-spacing: 0.08em;
        color: var(--accent);
      }
      header .subtitle {
        font-size: 0.7rem;
        color: var(--text-dim);
        letter-spacing: 0.15em;
        text-transform: uppercase;
      }

      .panels {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 14px;
        margin-bottom: 14px;
      }
      .panel {
        background: var(--bg2);
        border: 1px solid var(--border);
        border-radius: 2px;
        padding: 14px;
      }
      .panel-full {
        background: var(--bg2);
        border: 1px solid var(--border);
        border-radius: 2px;
        padding: 14px;
        margin-bottom: 14px;
      }
      .panel-title {
        font-family: var(--display);
        font-size: 0.95rem;
        letter-spacing: 0.12em;
        color: var(--accent2);
        margin-bottom: 10px;
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .panel-title::after {
        content: "";
        flex: 1;
        height: 1px;
        background: var(--border);
      }

      /* RHYTHM GRID */
      .rhythm-grid {
        display: flex;
        gap: 3px;
        margin-bottom: 10px;
        flex-wrap: nowrap;
      }
      .cell {
        height: 30px;
        min-width: 18px;
        flex: 1;
        border-radius: 2px;
        cursor: pointer;
        border: 1px solid transparent;
        transition: background 0.08s;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .cell.on {
        background: var(--on);
        border-color: #79ebd5;
        box-shadow: 0 0 5px rgba(92, 203, 182, 0.35);
      }
      .cell.off {
        background: var(--rest);
        border-color: var(--rest-border);
      }
      .cell.extended {
        background: #235d64;
        border-color: #388f98;
        box-shadow: 0 0 5px rgba(56, 143, 152, 0.4);
      }
      .cell.playhead {
        outline: 2px solid var(--accent3);
        outline-offset: 1px;
      }
      .cell-num {
        font-size: 0.48rem;
        color: rgba(0, 0, 0, 0.4);
        position: absolute;
        bottom: 1px;
        right: 2px;
      }
      .cell.off .cell-num,
      .cell.extended .cell-num {
        color: rgba(255, 255, 255, 0.2);
      }

      .beat-markers {
        display: flex;
        gap: 3px;
        margin-bottom: 6px;
      }
      .beat-mark {
        height: 4px;
        flex: 1;
        background: transparent;
      }
      .beat-mark.beat {
        background: var(--accent);
        border-radius: 1px;
      }

      /* BAR CONTROLS */
      .bar-controls {
        display: flex;
        align-items: center;
        gap: 6px;
        margin-bottom: 8px;
        flex-wrap: wrap;
      }
      .bar-tab {
        font-family: var(--mono);
        font-size: 0.65rem;
        padding: 3px 8px;
        border: 1px solid var(--border);
        background: transparent;
        color: var(--text-dim);
        border-radius: 2px;
        cursor: pointer;
        transition: all 0.1s;
      }
      .bar-tab.active {
        border-color: var(--accent);
        color: var(--accent);
        background: rgba(92, 203, 182, 0.1);
      }
      .bar-tab-del {
        font-size: 0.6rem;
        padding: 3px 5px;
        border: 1px solid transparent;
        background: transparent;
        color: var(--danger);
        border-radius: 2px;
        cursor: pointer;
        opacity: 0.5;
      }
      .bar-tab-del:hover {
        opacity: 1;
        border-color: var(--danger);
      }

      /* LENGTH CONTROL */
      .len-control {
        display: flex;
        align-items: center;
        gap: 6px;
        margin-bottom: 8px;
      }
      .len-input {
        width: 52px;
        background: var(--bg3);
        border: 1px solid var(--accent);
        color: var(--accent);
        font-family: var(--mono);
        font-size: 0.85rem;
        padding: 4px 6px;
        border-radius: 2px;
        outline: none;
        text-align: center;
      }
      .len-label {
        font-size: 0.65rem;
        color: var(--text-dim);
        text-transform: uppercase;
        letter-spacing: 0.1em;
      }

      /* EXTENDED NOTES TOGGLE */
      .ext-toggle {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .toggle-label {
        font-size: 0.65rem;
        color: var(--text-dim);
        text-transform: uppercase;
        letter-spacing: 0.08em;
      }
      .toggle-sw {
        position: relative;
        width: 38px;
        height: 20px;
        cursor: pointer;
      }
      .toggle-sw input {
        opacity: 0;
        width: 0;
        height: 0;
      }
      .toggle-track {
        position: absolute;
        inset: 0;
        background: var(--bg3);
        border: 1px solid var(--border);
        border-radius: 10px;
        transition: 0.2s;
      }
      .toggle-track::after {
        content: "";
        position: absolute;
        width: 14px;
        height: 14px;
        background: var(--text-dim);
        border-radius: 50%;
        top: 2px;
        left: 2px;
        transition: 0.2s;
      }
      .toggle-sw input:checked + .toggle-track {
        background: rgba(56, 143, 152, 0.3);
        border-color: #388f98;
      }
      .toggle-sw input:checked + .toggle-track::after {
        background: #388f98;
        left: 20px;
      }

      /* TRANSFORMS */
      .tx-btn {
        font-family: var(--mono);
        font-size: 0.68rem;
        letter-spacing: 0.04em;
        padding: 5px 10px;
        border-radius: 2px;
        border: 1px solid var(--border);
        background: var(--bg3);
        color: var(--text-dim);
        cursor: pointer;
        transition: all 0.12s;
        white-space: nowrap;
      }
      .tx-btn:hover {
        border-color: var(--accent2);
        color: var(--accent2);
      }
      .tx-num {
        width: 38px;
        background: var(--bg3);
        border: 1px solid var(--border);
        color: var(--text);
        font-family: var(--mono);
        font-size: 0.75rem;
        padding: 4px 5px;
        border-radius: 2px;
        outline: none;
        text-align: center;
      }
      .tx-group {
        display: flex;
        flex-direction: column;
        gap: 5px;
        margin-bottom: 8px;
      }
      .tx-group-label {
        font-size: 0.58rem;
        color: var(--text-dim);
        text-transform: uppercase;
        letter-spacing: 0.1em;
      }
      .tx-row {
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
        align-items: center;
      }

      /* INTERVAL EDITOR */
      .int-block {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 2px;
      }
      .int-input {
        width: 40px;
        height: 38px;
        background: var(--bg3);
        border: 1px solid var(--accent);
        color: var(--accent);
        font-family: var(--mono);
        font-size: 1rem;
        font-weight: 700;
        text-align: center;
        border-radius: 2px;
        outline: none;
      }
      .int-arrow {
        width: 40px;
        height: 18px;
        background: transparent;
        border: 1px solid var(--border);
        color: var(--text-dim);
        font-size: 0.5rem;
        cursor: pointer;
        border-radius: 2px;
        transition: all 0.1s;
      }
      .int-arrow:hover {
        border-color: var(--accent);
        color: var(--accent);
      }
      .int-rem {
        width: 18px;
        height: 14px;
        background: transparent;
        border: none;
        color: var(--danger);
        font-size: 0.7rem;
        cursor: pointer;
        opacity: 0.5;
      }
      .int-rem:hover {
        opacity: 1;
      }
      .plus-btn {
        width: 28px;
        height: 28px;
        background: transparent;
        border: 1px dashed var(--border);
        color: var(--text-dim);
        font-size: 1.1rem;
        cursor: pointer;
        border-radius: 2px;
        transition: all 0.12s;
      }
      .plus-btn:hover {
        border-color: var(--accent);
        color: var(--accent);
      }
      .root-select {
        background: var(--bg3);
        border: 1px solid var(--accent2);
        color: var(--accent2);
        font-family: var(--mono);
        font-size: 0.85rem;
        padding: 3px 7px;
        border-radius: 2px;
        outline: none;
        cursor: pointer;
      }

      /* PITCH PREVIEW */
      .pitch-preview {
        display: flex;
        gap: 3px;
        flex-wrap: wrap;
        padding: 7px;
        background: var(--bg);
        border: 1px solid var(--border);
        border-radius: 2px;
        min-height: 28px;
        margin-bottom: 8px;
      }
      .pitch-chip {
        font-size: 0.6rem;
        padding: 2px 5px;
        border-radius: 2px;
        background: rgba(181, 143, 218, 0.15);
        border: 1px solid var(--accent2);
        color: var(--accent2);
      }

      /* ADDITIVE PROCESS PANEL */
      .process-grid {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 12px;
      }
      .process-box {
        background: var(--bg3);
        border: 1px solid var(--border);
        border-radius: 2px;
        padding: 12px;
      }
      .process-box-title {
        font-size: 0.68rem;
        color: var(--accent3);
        text-transform: uppercase;
        letter-spacing: 0.1em;
        margin-bottom: 8px;
      }
      .process-params {
        display: flex;
        flex-direction: column;
        gap: 6px;
        margin-bottom: 10px;
      }
      .param-row {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .param-label {
        font-size: 0.63rem;
        color: var(--text-dim);
        min-width: 100px;
      }
      .param-input {
        width: 54px;
        background: var(--bg);
        border: 1px solid var(--border);
        color: var(--text);
        font-family: var(--mono);
        font-size: 0.8rem;
        padding: 3px 6px;
        border-radius: 2px;
        outline: none;
        text-align: center;
      }
      .param-select {
        background: var(--bg);
        border: 1px solid var(--border);
        color: var(--text);
        font-family: var(--mono);
        font-size: 0.72rem;
        padding: 3px 6px;
        border-radius: 2px;
        outline: none;
        cursor: pointer;
      }
      .gen-btn {
        font-family: var(--mono);
        font-size: 0.72rem;
        padding: 7px 14px;
        border-radius: 2px;
        border: 1px solid var(--accent3);
        background: rgba(75, 156, 184, 0.12);
        color: var(--accent3);
        cursor: pointer;
        transition: all 0.15s;
        letter-spacing: 0.05em;
        width: 100%;
      }
      .gen-btn:hover {
        background: rgba(75, 156, 184, 0.25);
      }
      .process-preview {
        font-size: 0.6rem;
        color: var(--text-dim);
        margin-top: 8px;
        min-height: 32px;
        line-height: 1.7;
      }

      /* BLOCKS */
      .blocks-row {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: flex-start;
        margin-bottom: 10px;
        min-height: 52px;
      }
      .block {
        background: var(--bg3);
        border: 1px solid var(--border);
        border-radius: 2px;
        padding: 7px 9px;
        font-size: 0.64rem;
        cursor: pointer;
        transition: all 0.12s;
        max-width: 170px;
        position: relative;
        border-top-width: 3px;
      }
      .block:hover {
        filter: brightness(1.2);
      }
      .block-name {
        font-family: var(--display);
        font-size: 0.82rem;
        letter-spacing: 0.06em;
        margin-bottom: 3px;
      }
      .block-rhythm {
        color: var(--text-dim);
        font-size: 0.57rem;
        line-height: 1.5;
        word-break: break-all;
      }
      .block-del {
        position: absolute;
        top: 3px;
        right: 5px;
        background: none;
        border: none;
        color: var(--danger);
        cursor: pointer;
        font-size: 0.9rem;
        opacity: 0.45;
      }
      .block-del:hover {
        opacity: 1;
      }
      .block-ext-badge {
        display: inline-block;
        font-size: 0.48rem;
        border: 1px solid currentColor;
        border-radius: 2px;
        padding: 0 3px;
        margin-left: 4px;
      }
      .store-btn {
        font-family: var(--mono);
        font-size: 0.68rem;
        padding: 5px 12px;
        background: rgba(88, 166, 255, 0.12);
        border: 1px solid var(--accent3);
        color: var(--accent3);
        border-radius: 2px;
        cursor: pointer;
        transition: all 0.12s;
      }
      .store-btn:hover {
        background: rgba(88, 166, 255, 0.28);
      }

      /* SEQUENCE */
      .sequence-slots {
        display: flex;
        gap: 5px;
        flex-wrap: wrap;
        min-height: 44px;
        padding: 7px;
        background: var(--bg);
        border: 1px dashed var(--border);
        border-radius: 2px;
        margin-bottom: 8px;
        align-items: center;
      }
      .seq-slot {
        background: var(--bg3);
        border: 1px solid var(--border);
        border-radius: 2px;
        padding: 3px 8px;
        font-size: 0.65rem;
        display: flex;
        align-items: center;
        gap: 5px;
        cursor: default;
        transition: 0.1s;
        border-bottom-width: 3px;
      }
      .seq-slot.active {
        background: var(--accent);
        color: var(--bg);
      }
      .seq-slot .del {
        color: var(--danger);
        cursor: pointer;
        font-size: 0.95rem;
        opacity: 0.6;
      }
      .seq-slot.active .del {
        color: var(--bg);
        opacity: 0.8;
      }
      .seq-slot .del:hover {
        opacity: 1;
      }
      .seq-hint {
        color: var(--text-dim);
        font-size: 0.65rem;
      }

      /* OMN OUTPUT */
      .omn-output {
        background: var(--bg);
        border: 1px solid var(--border);
        border-radius: 2px;
        padding: 12px;
        font-family: var(--mono);
        font-size: 0.72rem;
        color: var(--green);
        line-height: 1.8;
        white-space: pre-wrap;
        word-break: break-all;
        min-height: 70px;
        max-height: 180px;
        overflow-y: auto;
        margin-bottom: 8px;
      }

      /* PLAYBACK */
      .playback-bar {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 10px 14px;
        background: var(--bg2);
        border: 1px solid var(--border);
        border-radius: 2px;
        margin-bottom: 14px;
        flex-wrap: wrap;
      }
      .play-btn {
        width: 38px;
        height: 38px;
        border-radius: 50%;
        border: 2px solid var(--accent);
        background: transparent;
        color: var(--accent);
        font-size: 0.9rem;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.12s;
      }
      .play-btn:hover {
        background: rgba(92, 203, 182, 0.18);
      }
      .play-btn.playing {
        border-color: var(--green);
        color: var(--green);
      }
      .play-label {
        font-size: 0.62rem;
        color: var(--text-dim);
        letter-spacing: 0.1em;
        text-transform: uppercase;
      }
      .tempo-group {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-left: auto;
      }
      .tempo-slider {
        -webkit-appearance: none;
        appearance: none;
        width: 150px;
        height: 6px;
        border-radius: 3px;
        background: var(--border);
        outline: none;
        cursor: pointer;
      }
      .tempo-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: var(--accent);
        cursor: pointer;
      }
      .tempo-val {
        font-size: 0.78rem;
        color: var(--accent);
        min-width: 48px;
      }
      .waveform-select {
        background: var(--bg3);
        border: 1px solid var(--border);
        color: var(--text-dim);
        font-family: var(--mono);
        font-size: 0.68rem;
        padding: 3px 7px;
        border-radius: 2px;
        outline: none;
        cursor: pointer;
      }
      .copy-btn {
        font-family: var(--mono);
        font-size: 0.68rem;
        padding: 5px 10px;
        background: rgba(75, 200, 123, 0.1);
        border: 1px solid var(--green);
        color: var(--green);
        border-radius: 2px;
        cursor: pointer;
        transition: all 0.12s;
      }
      .copy-btn:hover {
        background: rgba(75, 200, 123, 0.22);
      }

      .status-flash {
        position: fixed;
        bottom: 18px;
        right: 18px;
        background: var(--accent);
        color: var(--bg);
        font-family: var(--mono);
        font-size: 0.72rem;
        padding: 7px 14px;
        border-radius: 2px;
        z-index: 999;
        opacity: 0;
        transform: translateY(8px);
        transition: all 0.25s;
        pointer-events: none;
      }
      .status-flash.show {
        opacity: 1;
        transform: translateY(0);
      }

      ::-webkit-scrollbar {
        width: 4px;
      }
      ::-webkit-scrollbar-track {
        background: var(--bg2);
      }
      ::-webkit-scrollbar-thumb {
        background: var(--border);
        border-radius: 2px;
      }

      .add-bar-btn {
        font-family: var(--mono);
        font-size: 0.65rem;
        padding: 3px 7px;
        border: 1px dashed var(--border);
        background: transparent;
        color: var(--text-dim);
        border-radius: 2px;
        cursor: pointer;
        transition: all 0.1s;
      }
      .add-bar-btn:hover {
        border-color: var(--accent);
        color: var(--accent);
      }

      .interval-strip {
        display: flex;
        align-items: flex-end;
        gap: 6px;
        flex-wrap: wrap;
        margin-bottom: 10px;
      }

      hr.sep {
        border: none;
        border-top: 1px solid var(--border);
        margin: 10px 0;
      }
    </style>
  </head>
  <body>
    <div class="app">
      <header style="display:flex; justify-content:space-between; align-items:center;">
        <div>
          <h1>OMN WORKBENCH</h1>
          <span class="subtitle"
            >v2 · variable length · additive/subtractive process · extended
            notes</span
          >
        </div>
        <div style="display:flex; gap:8px;">
          <button class="store-btn" onclick="saveConfig()">Save Config</button>
          <button class="copy-btn" onclick="loadConfig()">Load Config</button>
        </div>
      </header>

      <!-- PLAYBACK BAR -->
      <div class="playback-bar">
        <button class="play-btn" id="playBtn" title="Play current bar">
          ▶
        </button>
        <div class="play-label">Current</div>
        <label class="toggle-sw" style="margin-left: 5px">
          <input type="checkbox" id="loopToggle" checked />
          <span class="toggle-track"></span>
        </label>
        <div class="play-label" style="text-transform: lowercase">Loop</div>
        <button
          class="play-btn"
          id="playSeqBtn"
          title="Play sequence"
          style="
            width: 34px;
            height: 34px;
            font-size: 0.75rem;
            margin-left: 14px;
          "
        >
          ▶▶
        </button>
        <div class="play-label">Sequence</div>
        <label class="toggle-sw" style="margin-left: 5px">
          <input type="checkbox" id="seqLoopToggle" />
          <span class="toggle-track"></span>
        </label>
        <div class="play-label" style="text-transform: lowercase">Loop</div>
        <div class="tempo-group">
          <span class="play-label">BPM</span>
          <input
            type="range"
            class="tempo-slider"
            id="tempoSlider"
            min="40"
            max="240"
            value="120"
          />
          <span class="tempo-val" id="tempoVal">120 ♩</span>
        </div>
        <select class="waveform-select" id="waveform">
          <option value="sine">sine</option>
          <option value="triangle" selected>triangle</option>
          <option value="sawtooth">sawtooth</option>
          <option value="square">square</option>
        </select>
      </div>

      <!-- RHYTHM EDITOR -->
      <div class="panel-full">
        <div class="panel-title">RHYTHM EDITOR</div>

        <!-- Bar tabs row -->
        <div class="bar-controls" id="barTabRow"></div>

        <!-- Length + extended notes row -->
        <div
          style="
            display: flex;
            align-items: center;
            gap: 18px;
            margin-bottom: 8px;
            flex-wrap: wrap;
          "
        >
          <div class="len-control">
            <span class="len-label">Pulses</span>
            <input
              type="number"
              class="len-input"
              id="barLenInput"
              min="2"
              max="64"
              value="16"
            />
            <button class="tx-btn" onclick="applyBarLen()">set</button>
            <button class="tx-btn" onclick="trimBarLen()">
              trim to last note
            </button>
          </div>
          <div class="ext-toggle">
            <span class="toggle-label">Extended notes</span>
            <label class="toggle-sw">
              <input type="checkbox" id="extToggle" onchange="renderAll()" />
              <span class="toggle-track"></span>
            </label>
            <span
              style="font-size: 0.6rem; color: var(--text-dim)"
              id="extHint"
            ></span>
          </div>
        </div>

        <!-- Beat markers -->
        <div class="beat-markers" id="beatMarkers"></div>
        <!-- Grid -->
        <div class="rhythm-grid" id="rhythmGrid"></div>

        <!-- Rhythm transforms -->
        <div class="tx-group">
          <div class="tx-group-label">Rhythm transforms</div>
          <div class="tx-row">
            <button class="tx-btn" onclick="rhythmRotate(1)">rotate →1</button>
            <button class="tx-btn" onclick="rhythmRotate(-1)">rotate ←1</button>
            <button class="tx-btn" onclick="rhythmRotateN()">
              rotate N
              <input
                type="number"
                class="tx-num"
                id="rotN"
                value="2"
                style="margin-left: 4px; width: 36px"
              />
            </button>
            <button class="tx-btn" onclick="rhythmRetrograde()">
              retrograde
            </button>
            <button class="tx-btn" onclick="rhythmComplement()">
              complement
            </button>
            <button class="tx-btn" onclick="rhythmSubseq()">
              subseq [<input
                class="tx-num"
                id="ssStart"
                value="0"
                style="width: 28px"
              />:<input
                class="tx-num"
                id="ssEnd"
                value="14"
                style="width: 28px"
              />]
            </button>
          </div>
        </div>
      </div>

      <!-- PITCH + OMN side by side -->
      <div class="panels">
        <div class="panel">
          <div class="panel-title">PITCH / INTERVAL</div>
          <div
            style="
              display: flex;
              align-items: center;
              gap: 10px;
              margin-bottom: 8px;
              flex-wrap: wrap;
            "
          >
            <span style="font-size: 0.65rem; color: var(--text-dim)">root</span>
            <select class="root-select" id="rootNote">
              <option>c3</option>
              <option>cs3</option>
              <option>d3</option>
              <option>eb3</option>
              <option>e3</option>
              <option>f3</option>
              <option>fs3</option>
              <option value="g3" selected>g3</option>
              <option>ab3</option>
              <option>a3</option>
              <option>bb3</option>
              <option>b3</option>
              <option>c4</option>
              <option>cs4</option>
              <option>d4</option>
              <option>eb4</option>
              <option>e4</option>
              <option>f4</option>
              <option>fs4</option>
              <option>g4</option>
              <option>ab4</option>
              <option>a4</option>
              <option>bb4</option>
              <option>b4</option>
            </select>
            <span style="font-size: 0.65rem; color: var(--text-dim)"
              >intervals (semitones)</span
            >
            <button class="plus-btn" onclick="addInterval()">+</button>
          </div>
          <div class="interval-strip" id="intervalStrip"></div>
          <div
            style="
              font-size: 0.6rem;
              color: var(--text-dim);
              letter-spacing: 0.08em;
              text-transform: uppercase;
              margin-bottom: 5px;
            "
          >
            Generated pitches
          </div>
          <div class="pitch-preview" id="pitchPreview"></div>
          <div class="tx-group">
            <div class="tx-group-label">Pitch transforms</div>
            <div class="tx-row">
              <button class="tx-btn" onclick="pitchTranspose()">
                transpose
                <input
                  class="tx-num"
                  id="transN"
                  value="5"
                  style="width: 32px"
                />
              </button>
              <button class="tx-btn" onclick="pitchInvert()">invert</button>
              <button class="tx-btn" onclick="pitchRetrograde()">
                retrograde
              </button>
              <button class="tx-btn" onclick="pitchRotate(1)">rotate →</button>
              <button class="tx-btn" onclick="pitchRotate(-1)">rotate ←</button>
            </div>
          </div>
        </div>

        <div class="panel">
          <div class="panel-title">CURRENT OMN</div>
          <div class="omn-output" id="omnOutput">;; OMN output</div>
          <div style="display: flex; gap: 8px; flex-wrap: wrap">
            <button class="copy-btn" onclick="copyOMN()">copy OMN</button>
            <button class="store-btn" onclick="storeBlock()">
              → store as block
            </button>
          </div>
        </div>
      </div>

      <!-- ADDITIVE / SUBTRACTIVE PROCESS -->
      <div class="panel-full">
        <div style="display:flex; justify-content:space-between; align-items:flex-end; margin-bottom:15px; border-bottom:1px solid var(--border); padding-bottom:10px;">
          <div class="panel-title" style="margin-bottom:0; border-bottom:none; padding-bottom:0;">PROCESS GENERATORS</div>
          <div style="font-family:var(--display); font-size:1.0rem; color:var(--accent2); display:flex; gap:10px; align-items:center;">
             <label style="display:flex; align-items:center; gap:4px; font-size:0.75rem; color:var(--text-dim); margin-right:5px; font-family:var(--mono); border:1px solid var(--border); padding:3px 8px; border-radius:2px; cursor:pointer;" title="Adds generated blocks automatically to the end of your sequence">
               <input type="checkbox" id="autoAddSeqOverlay" /> auto-add blocks to sequence
             </label>
             <span style="letter-spacing:0.05em">PITCH OVERLAYS:</span>
             <div id="pitchStack" style="display:flex; gap:5px; flex-wrap:wrap;">
               <select class="pitch-layer-select" style="font-family:var(--mono); font-size:0.75rem; background:var(--bg2); color:var(--accent2); border:1px solid var(--border); padding:3px 8px; border-radius:2px; cursor:pointer;">
                  <option value="none">None (Static Pitch)</option>
                  <option value="invert">Alternate: Invert Intervals (Up ⇄ Down)</option>
                  <option value="retrograde-sequence">Alternate: Retrograde Pitches (Backwards)</option>
                  <option value="retrograde">Alternate: Retrograde Interval Array</option>
                  <option disabled>──────────</option>
                  <option value="torke-up">Progressive: Torke Up (Raise note 1-by-1)</option>
                  <option value="torke-down">Progressive: Torke Down (Lower note 1-by-1)</option>
                  <option value="expand">Progressive: Expand Intervals (+1)</option>
                  <option value="contract">Progressive: Contract Intervals (-1)</option>
                  <option value="transpose-up">Progressive: Transpose Up (+half step)</option>
                  <option value="transpose-down">Progressive: Transpose Down (-half step)</option>
                  <option value="rotate">Progressive: Rotate Intervals</option>
               </select>
             </div>
             <button onclick="addPitchLayer()" style="background:none; border:1px solid #56d364; color:#56d364; cursor:pointer; padding:2px 6px; border-radius:2px; font-weight:bold; font-size:0.7rem;">+</button>
             <button onclick="removePitchLayer()" style="background:none; border:1px solid var(--danger); color:var(--danger); cursor:pointer; padding:2px 7px; border-radius:2px; font-weight:bold; font-size:0.7rem;">-</button>
          </div>
        </div>
        <div class="process-grid">
          <!-- ADDITIVE MODE -->
          <div class="process-box">
            <div class="process-box-title">Additive</div>
            <div
              style="
                font-size: 0.6rem;
                color: var(--text-dim);
                margin-bottom: 8px;
                line-height: 1.6;
              "
            >
              Adds or removes notes within the existing bar length. Bar length
              stays fixed; pattern density changes.
            </div>
            <div class="process-params">
              <div class="param-row">
                <span class="param-label">Direction</span>
                <select class="param-select" id="glassDir">
                  <option value="add">additive (+1 per step)</option>
                  <option value="sub">subtractive (−1 per step)</option>
                  <option value="add-sub">add then subtract</option>
                  <option value="sub-add">subtract then add</option>
                </select>
              </div>
              <div class="param-row">
                <span class="param-label">Start from</span>
                <select class="param-select" id="glassStart">
                  <option value="current">current bar</option>
                  <option value="full">all notes on</option>
                  <option value="empty">all notes off</option>
                  <option value="single">single note (pos 0)</option>
                </select>
              </div>
              <div class="param-row">
                <span class="param-label">Add/remove position</span>
                <select class="param-select" id="glassPos">
                  <option value="end">from end</option>
                  <option value="start">from start</option>
                  <option value="mid">from middle out</option>
                  <option value="alt">alternating</option>
                </select>
              </div>
              <div class="param-row">
                <span class="param-label">Repetitions/step</span>
                <input
                  class="param-input"
                  id="glassReps"
                  type="number"
                  value="2"
                  min="1"
                  max="16"
                />
              </div>
            </div>
            <div class="process-preview" id="glassPreview"></div>
            <button class="gen-btn" onclick="generateGlass()">
              Generate Additive process → blocks
            </button>
          </div>

          <!-- PHASE MODE -->
          <div class="process-box">
            <div class="process-box-title">Phase</div>
            <div
              style="
                font-size: 0.6rem;
                color: var(--text-dim);
                margin-bottom: 8px;
                line-height: 1.6;
              "
            >
              Shifts a subsection of the bar over time while leaving the rest intact.
            </div>
            <div class="process-params">
              <div class="param-row">
                <span class="param-label">Shift start pos</span>
                <input class="param-input" id="phaseStart" type="number" value="0" min="0" max="63" />
              </div>
              <div class="param-row">
                <span class="param-label">Shift end pos</span>
                <input class="param-input" id="phaseEnd" type="number" value="15" min="0" max="63" />
              </div>
              <div class="param-row">
                <span class="param-label">Shift direction</span>
                <select class="param-select" id="phaseDir">
                  <option value="right">Right (delay)</option>
                  <option value="left">Left (anticipate)</option>
                </select>
              </div>
              <div class="param-row">
                <span class="param-label">Shift amount</span>
                <input class="param-input" id="phaseStep" type="number" value="1" min="1" max="16" />
              </div>
              <div class="param-row">
                <span class="param-label">Total Shifts</span>
                <input class="param-input" id="phaseTotal" type="number" value="8" min="1" max="64" />
              </div>
            </div>
            <div class="process-preview" id="phasePreview"></div>
            <button class="gen-btn" onclick="generatePhase()">
              Generate Phase process → blocks
            </button>
          </div>

          <!-- BLOCK ADDITIVE MODE -->
          <div class="process-box">
            <div class="process-box-title">Block Additive</div>
            <div
              style="
                font-size: 0.6rem;
                color: var(--text-dim);
                margin-bottom: 8px;
                line-height: 1.6;
              "
            >
              Grows or shrinks the bar length itself by adding/removing pulses.
              Changes the metrical unit.
            </div>
            <div class="process-params">
              <div class="param-row">
                <span class="param-label">Direction</span>
                <select class="param-select" id="reichDir">
                  <option value="add">additive (grow)</option>
                  <option value="sub">subtractive (shrink)</option>
                  <option value="add-sub">grow then shrink</option>
                  <option value="sub-add">shrink then grow</option>
                </select>
              </div>
              <div class="param-row">
                <span class="param-label">Start length</span>
                <input
                  class="param-input"
                  id="reichStart"
                  type="number"
                  value="4"
                  min="1"
                  max="32"
                />
              </div>
              <div class="param-row">
                <span class="param-label">End length</span>
                <input
                  class="param-input"
                  id="reichEnd"
                  type="number"
                  value="16"
                  min="1"
                  max="32"
                />
              </div>
              <div class="param-row">
                <span class="param-label">Step size</span>
                <input
                  class="param-input"
                  id="reichStep"
                  type="number"
                  value="1"
                  min="1"
                  max="8"
                />
              </div>
              <div class="param-row">
                <span class="param-label">Repetitions/step</span>
                <input
                  class="param-input"
                  id="reichReps"
                  type="number"
                  value="2"
                  min="1"
                  max="16"
                />
              </div>
              <div class="param-row">
                <span class="param-label">Fill pattern</span>
                <select class="param-select" id="reichFill">
                  <option value="current">from current bar pattern</option>
                  <option value="all">all notes on</option>
                  <option value="alt">alternating 1 0</option>
                </select>
              </div>
            </div>
            <button class="gen-btn" onclick="generateReich()">
              Generate Block Additive process → blocks
            </button>
          </div>
        </div>
      </div>

      <!-- BLOCK LIBRARY -->
      <div class="panel-full">
        <div style="display:flex; justify-content:space-between; align-items:flex-end; margin-bottom:10px;">
          <div class="panel-title" style="margin-bottom:0;">BLOCK LIBRARY</div>
          <button class="tx-btn" style="border:1px solid var(--border); border-radius:3px; padding:2px 6px;" onclick="clearBlocks()">clear library</button>
        </div>
        <div class="blocks-row" id="blocksRow">
          <span class="seq-hint"
            >Store transformations here. Click a block to load it, double-click
            to add to sequence.</span
          >
        </div>
      </div>

      <!-- SEQUENCE BUILDER -->
      <div class="panel-full">
        <div style="display:flex; justify-content:space-between; align-items:flex-end; margin-bottom:10px;">
          <div class="panel-title" style="margin-bottom:0;">SEQUENCE BUILDER</div>
          <div style="display: flex; gap: 8px; align-items: center;">
            <button class="copy-btn" onclick="copyFullSequence()">copy full OMN</button>
            <button class="tx-btn" style="border:1px solid var(--border); border-radius:3px; padding:2px 6px;" onclick="clearSequence()">clear sequence</button>
          </div>
        </div>
        <div class="sequence-slots" id="sequenceSlots">
          <span class="seq-hint"
            >Double-click blocks above · or click a block then click "→
            seq"</span
          >
        </div>
        <div class="omn-output" id="sequenceOMN" style="min-height: 40px">
          ;; Full sequence OMN
        </div>
      </div>
    </div>
    <div class="status-flash" id="statusFlash"></div>

    <script>
      // ══════════════════════════════════════════
      // NOTE HELPERS
      // ══════════════════════════════════════════
      const NOTE_NAMES = [
        "c",
        "cs",
        "d",
        "eb",
        "e",
        "f",
        "fs",
        "g",
        "ab",
        "a",
        "bb",
        "b",
      ];

      function noteToMidi(s) {
        const m = s.match(/^([a-z#b]+)(\d+)$/i);
        if (!m) return 60;
        const name = m[1].toLowerCase().replace("#", "s");
        const idx = NOTE_NAMES.indexOf(name);
        return (parseInt(m[2]) + 1) * 12 + idx;
      }

      function midiToOMN(midi) {
        const oct = Math.floor(midi / 12) - 1;
        return NOTE_NAMES[((midi % 12) + 12) % 12] + oct;
      }

      function midiToHz(midi) {
        return 440 * Math.pow(2, (midi - 69) / 12);
      }

      function generatePitches(root, ints, count) {
        const rootMidi = noteToMidi(root);
        let pitches = [rootMidi],
          cur = rootMidi;
        for (let i = 0; i < (count || 32); i++) {
          cur += ints[i % ints.length];
          pitches.push(cur);
        }
        return pitches;
      }

      // ══════════════════════════════════════════
      // STATE
      // ══════════════════════════════════════════
      // Each bar is an object: { cells: [0/1...], extended: bool }
      let bars = [
        {
          cells: [1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1],
          extended: false,
        },
        {
          cells: [1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
          extended: false,
        },
      ];
      let currentBar = 0;
      let intervals = [3, 4, 3, -4];
      let rootNote = "g3";
      let blocks = [];
      let sequence = [];
      let blockCounter = 1;
      let audioCtx = null;
      let isPlaying = false;
      let playbackTimeout = null;

      // ══════════════════════════════════════════
      // OMN LENGTH CALCULATION with extended notes
      // ══════════════════════════════════════════

      // Given binary array, collapse note+rest runs into extended notes.
      // Returns array of {length: string, isRest: bool} objects.
      function binaryToLengthTokens(cells, extended) {
        // Base unit is always s (1/16).
        // Extended: runs of 1 followed by 0s → tied/extended note (multiple of s).
        // We express as: e = 2s, e. = 3s, q = 4s, q. = 5s, h = 8s, etc.
        // For simplicity: use fractional notation understood by OMN: s, e, e., q, q., h, etc.
        // or just multiples via tied notes: s+s+s = s_s_s in OMN (tied) → "3s" doesn't exist,
        // but we can use: 3/16, 5/16 etc. OMN supports arbitrary fractions.

        const durMap = {
          1: "s",
          2: "e",
          3: "e.",
          4: "q",
          5: "q.",
          6: "3/8",
          7: "7/16",
          8: "h",
          9: "9/16",
          10: "5/8",
          11: "11/16",
          12: "h.",
          13: "13/16",
          14: "7/8",
          15: "15/16",
          16: "w",
        };

        if (!extended) {
          // Simple: each cell is s or -s
          return cells.map((c) => ({ dur: c ? "s" : "-s", isRest: !c }));
        }

        // Extended: greedily combine each note with following rests
        let tokens = [];
        let i = 0;
        while (i < cells.length) {
          if (cells[i] === 0) {
            // rest — count consecutive rests
            let count = 0;
            while (i < cells.length && cells[i] === 0) {
              count++;
              i++;
            }
            const restDur = durMap[count] || count + "/16";
            tokens.push({ dur: "-" + restDur, isRest: true });
          } else {
            // note — absorb following rests
            let noteLen = 1;
            i++;
            while (i < cells.length && cells[i] === 0) {
              noteLen++;
              i++;
            }
            const noteDur = durMap[noteLen] || noteLen + "/16";
            tokens.push({ dur: noteDur, isRest: false });
          }
        }
        return tokens;
      }

      // ══════════════════════════════════════════
      // BUILD OMN STRING
      // ══════════════════════════════════════════
      function buildOMNForBar(barObj, overrideRoot, overrideInts, reversePitches) {
        const { cells, extended } = barObj;
        const r = overrideRoot || rootNote;
        const i = overrideInts || intervals;
        const tokens = binaryToLengthTokens(cells, extended);
        const pitchCount = tokens.filter((t) => !t.isRest).length;
        // ensure we generate enough pitches for the actual note count in the bar
        let pitches = generatePitches(r, i, Math.max(pitchCount, cells.length));

        const lengths = [];
        const pitchList = [];
        let pitchIdx = 0;

        tokens.forEach((t) => {
          lengths.push(t.dur);
          if (!t.isRest) {
            pitchList.push(midiToOMN(pitches[pitchIdx++ % pitches.length]));
          }
        });

        if (reversePitches) {
          pitchList.reverse();
        }

        return {
          lengths,
          pitches: pitchList,
          omn: `(make-omn\n :length '(${lengths.join(" ")})\n :pitch '(${pitchList.join(" ")}))`,
        };
      }

      // ══════════════════════════════════════════
      // RENDER — BAR TABS
      // ══════════════════════════════════════════
      function renderBarTabs() {
        const row = document.getElementById("barTabRow");
        row.innerHTML = "";
        bars.forEach((b, i) => {
          const btn = document.createElement("button");
          btn.className = "bar-tab" + (i === currentBar ? " active" : "");
          btn.textContent = "Bar " + (i + 1) + " [" + b.cells.length + "]";
          btn.onclick = () => {
            currentBar = i;
            syncLenInput();
            renderAll();
          };
          row.appendChild(btn);
        });
        // add blank bar
        const addBtn = document.createElement("button");
        addBtn.className = "add-bar-btn";
        addBtn.textContent = "+ bar";
        addBtn.onclick = () => {
          bars.push({ cells: new Array(16).fill(0), extended: false });
          currentBar = bars.length - 1;
          syncLenInput();
          renderAll();
        };
        row.appendChild(addBtn);
        // del bar
        if (bars.length > 1) {
          const delBtn = document.createElement("button");
          delBtn.className = "bar-tab-del";
          delBtn.textContent = "✕ del";
          delBtn.onclick = () => {
            bars.splice(currentBar, 1);
            currentBar = Math.min(currentBar, bars.length - 1);
            syncLenInput();
            renderAll();
          };
          row.appendChild(delBtn);
        }
      }

      function syncLenInput() {
        document.getElementById("barLenInput").value =
          bars[currentBar].cells.length;
        document.getElementById("extToggle").checked =
          bars[currentBar].extended;
      }

      // ══════════════════════════════════════════
      // RENDER — BEAT MARKERS + GRID
      // ══════════════════════════════════════════
      function renderBeatMarkers() {
        const cont = document.getElementById("beatMarkers");
        cont.innerHTML = "";
        bars[currentBar].cells.forEach((_, i) => {
          const d = document.createElement("div");
          d.className = "beat-mark" + (i % 4 === 0 ? " beat" : "");
          d.style.flex = "1";
          cont.appendChild(d);
        });
      }

      function renderGrid(playheadIdx = -1) {
        const grid = document.getElementById("rhythmGrid");
        grid.innerHTML = "";
        const { cells, extended } = bars[currentBar];

        // Compute which cells are "absorbed" into a note (extended display)
        let absorbedSet = new Set();
        if (extended) {
          let i = 0;
          while (i < cells.length) {
            if (cells[i] === 1) {
              let j = i + 1;
              while (j < cells.length && cells[j] === 0) {
                absorbedSet.add(j);
                j++;
              }
              i = j;
            } else {
              i++;
            }
          }
        }

        cells.forEach((val, i) => {
          const cell = document.createElement("div");
          let cls = "cell ";
          if (val === 1) cls += "on";
          else if (extended && absorbedSet.has(i)) cls += "extended";
          else cls += "off";
          if (i === playheadIdx) cls += " playhead";
          cell.className = cls;

          const num = document.createElement("span");
          num.className = "cell-num";
          num.textContent = i + 1;
          cell.appendChild(num);

          cell.onclick = () => {
            bars[currentBar].cells[i] = bars[currentBar].cells[i] ? 0 : 1;
            renderAll();
          };
          grid.appendChild(cell);
        });
      }

      // ══════════════════════════════════════════
      // RENDER — INTERVAL STRIP + PITCH PREVIEW
      // ══════════════════════════════════════════
      function renderIntervalStrip() {
        const strip = document.getElementById("intervalStrip");
        strip.innerHTML = "";
        intervals.forEach((val, i) => {
          const blk = document.createElement("div");
          blk.className = "int-block";

          const up = document.createElement("button");
          up.className = "int-arrow";
          up.textContent = "▲";
          up.onclick = () => {
            intervals[i]++;
            renderAll();
          };

          const inp = document.createElement("input");
          inp.className = "int-input";
          inp.type = "number";
          inp.value = val;
          inp.onchange = (e) => {
            intervals[i] = parseInt(e.target.value) || 0;
            renderAll();
          };

          const down = document.createElement("button");
          down.className = "int-arrow";
          down.textContent = "▼";
          down.onclick = () => {
            intervals[i]--;
            renderAll();
          };

          const rem = document.createElement("button");
          rem.className = "int-rem";
          rem.textContent = "✕";
          rem.onclick = () => {
            intervals.splice(i, 1);
            renderAll();
          };

          blk.appendChild(up);
          blk.appendChild(inp);
          blk.appendChild(down);
          blk.appendChild(rem);
          strip.appendChild(blk);
        });
      }

      function renderPitchPreview() {
        const pitches = generatePitches(rootNote, intervals, 20);
        const prev = document.getElementById("pitchPreview");
        prev.innerHTML = "";
        pitches.slice(0, 18).forEach((m) => {
          const c = document.createElement("span");
          c.className = "pitch-chip";
          c.textContent = midiToOMN(m);
          prev.appendChild(c);
        });
      }

      // ══════════════════════════════════════════
      // RENDER — OMN OUTPUT
      // ══════════════════════════════════════════
      function renderOMN() {
        const { omn } = buildOMNForBar(bars[currentBar]);
        document.getElementById("omnOutput").textContent = omn;

        // Extended hint
        if (bars[currentBar].extended) {
          document.getElementById("extHint").textContent =
            "← on: rests absorbed into note durations";
        } else {
          document.getElementById("extHint").textContent = "";
        }
      }

      // ══════════════════════════════════════════
      // RENDER — BLOCKS
      // ══════════════════════════════════════════
      function renderBlocks() {
        const row = document.getElementById("blocksRow");
        row.innerHTML = "";
        if (blocks.length === 0) {
          row.innerHTML =
            '<span class="seq-hint">Store transformations here. Click to load, double-click to add to sequence.</span>';
          return;
        }
        blocks.forEach((b, i) => {
          const el = document.createElement("div");
          el.className = "block";
          const extBadge = b.extended
            ? '<span class="block-ext-badge">ext</span>'
            : "";
          el.style.borderTopColor = b.color;
          el.innerHTML = `
      <div class="block-name" style="color: ${b.color}">${b.name}${extBadge}</div>
      <div class="block-rhythm">[${b.cells.length}] ${b.cells.map((x) => (x ? "■" : "□")).join("")}</div>
      <div class="block-rhythm" style="color:var(--text-dim)">${b.pitchList.slice(0, 8).join(" ")}…</div>
      <button class="block-del" onclick="event.stopPropagation();deleteBlock(${i})">✕</button>
    `;
          // single click: load into editor
          el.onclick = () => loadBlock(i);
          // double click: add to sequence
          el.ondblclick = () => {
            addToSequence(i);
          };
          row.appendChild(el);
        });
      }

      // ══════════════════════════════════════════
      // RENDER — SEQUENCE
      // ══════════════════════════════════════════
      function renderSequenceSlots() {
        const slots = document.getElementById("sequenceSlots");
        slots.innerHTML = "";
        if (sequence.length === 0) {
          slots.innerHTML =
            '<span class="seq-hint">Double-click blocks above to add here</span>';
          return;
        }
        sequence.forEach((blockIdx, pos) => {
          const b = blocks[blockIdx];
          const el = document.createElement("div");
          el.className = "seq-slot";
          el.style.borderBottomColor = b.color;
          el.style.color = b.color;
          el.innerHTML = `${b.name} <span class="del" onclick="removeFromSequence(${pos})">✕</span>`;
          slots.appendChild(el);
        });
      }

      function highlightSequenceSlot(pos) {
        document.querySelectorAll(".seq-slot").forEach((el) =>
          el.classList.remove("active"),
        );
        if (pos >= 0) {
          const el = document.getElementById("seqSlot" + pos);
          if (el) el.classList.add("active");
        }
      }

      function renderSequenceOMN() {
        if (sequence.length === 0) {
          document.getElementById("sequenceOMN").textContent =
            ";; Add blocks to build sequence";
          return;
        }
        const lenParts = sequence.map((i) => {
          const b = blocks[i];
          return `  ;; ${b.name} [${b.cells.length}]\n  (${b.lengths.join(" ")})`;
        });
        const pitchParts = sequence.map((i) => {
          const b = blocks[i];
          return `  (${b.pitchList.join(" ")})`;
        });
        document.getElementById("sequenceOMN").textContent =
          `(make-omn\n :length '(\n${lenParts.join("\n")}\n )\n :pitch '(\n${pitchParts.join("\n")}\n ))`;
      }

      // ══════════════════════════════════════════
      // RENDER ALL
      // ══════════════════════════════════════════
      function renderAll() {
        // sync extended toggle from bar state
        document.getElementById("extToggle").checked =
          bars[currentBar].extended;
        renderBarTabs();
        renderBeatMarkers();
        renderGrid();
        renderIntervalStrip();
        renderPitchPreview();
        renderOMN();
        renderBlocks();
        renderSequenceSlots();
        renderSequenceOMN();
      }

      // ══════════════════════════════════════════
      // BAR LENGTH CONTROLS
      // ══════════════════════════════════════════
      function applyBarLen() {
        const n = Math.max(
          2,
          Math.min(
            64,
            parseInt(document.getElementById("barLenInput").value) || 16,
          ),
        );
        const cur = bars[currentBar].cells;
        if (n > cur.length) {
          while (bars[currentBar].cells.length < n)
            bars[currentBar].cells.push(0);
        } else {
          bars[currentBar].cells = cur.slice(0, n);
        }
        renderAll();
      }

      function trimBarLen() {
        const cells = bars[currentBar].cells;
        let last = cells.length - 1;
        while (last > 0 && cells[last] === 0) last--;
        bars[currentBar].cells = cells.slice(0, last + 1);
        syncLenInput();
        renderAll();
      }

      document.getElementById("extToggle").onchange = function () {
        bars[currentBar].extended = this.checked;
        renderAll();
      };

      document.getElementById("rootNote").onchange = function () {
        rootNote = this.value;
        renderAll();
      };

      // ══════════════════════════════════════════
      // RHYTHM TRANSFORMS
      // ══════════════════════════════════════════
      function rhythmRotate(n) {
        const cells = bars[currentBar].cells;
        const len = cells.length;
        const r = ((n % len) + len) % len;
        bars[currentBar].cells = [
          ...cells.slice(len - r),
          ...cells.slice(0, len - r),
        ];
        renderAll();
      }
      function rhythmRotateN() {
        rhythmRotate(parseInt(document.getElementById("rotN").value) || 1);
      }
      function rhythmRetrograde() {
        bars[currentBar].cells = [...bars[currentBar].cells].reverse();
        renderAll();
      }
      function rhythmComplement() {
        bars[currentBar].cells = bars[currentBar].cells.map((x) => (x ? 0 : 1));
        renderAll();
      }
      function rhythmSubseq() {
        const s = parseInt(document.getElementById("ssStart").value) || 0;
        const e = parseInt(document.getElementById("ssEnd").value) || 14;
        // Slice is exclusive at end — so 0:14 gives indices 0..13 = 14 cells, matching Opusmodus subseq
        bars[currentBar].cells = bars[currentBar].cells.slice(s, e);
        // NO padding — the bar is exactly as long as the slice
        syncLenInput();
        renderAll();
      }

      // ══════════════════════════════════════════
      // PITCH TRANSFORMS
      // ══════════════════════════════════════════
      function pitchTranspose() {
        const n = parseInt(document.getElementById("transN").value) || 0;
        rootNote = midiToOMN(
          Math.max(36, Math.min(96, noteToMidi(rootNote) + n)),
        );
        document.getElementById("rootNote").value = rootNote;
        renderAll();
      }
      function pitchInvert() {
        const N = intervals.length;
        if(N === 0) return;
        // The new root is the highest pitch in the current cycle
        const topPitchFreq = intervals.reduce((sum, curr) => sum + curr, 0);
        const rm = noteToMidi(rootNote);
        rootNote = midiToOMN(rm + topPitchFreq);
        intervals = intervals.map((x) => -x).reverse();
        renderAll();
      }
      function pitchRetrograde() {
        intervals = [...intervals].reverse();
        renderAll();
      }
      function pitchRotate(n) {
        const len = intervals.length;
        if (!len) return;
        const r = ((n % len) + len) % len;
        intervals = [
          ...intervals.slice(len - r),
          ...intervals.slice(0, len - r),
        ];
        renderAll();
      }
      function addInterval() {
        intervals.push(2);
        renderAll();
      }

      // ══════════════════════════════════════════
      // PITCH EVOLUTION LOGIC
      // ══════════════════════════════════════════
      function applyPitchProcess(baseInts, baseRoot, type, step) {
        if (type === "none" || step === 0) return { root: baseRoot, ints: [...baseInts] };
        
        let newInts = [...baseInts];
        let rootMidi = noteToMidi(baseRoot);
        const N = newInts.length;
        if (N === 0) {
           if (type === "transpose-up") return { root: midiToOMN(rootMidi + step), ints: [] };
           if (type === "transpose-down") return { root: midiToOMN(rootMidi - step), ints: [] };
           return { root: baseRoot, ints: [] };
        }

        for (let s = 1; s <= step; s++) {
          if (type === "torke-up") {
            let target = N - ((s - 1) % N) - 1; 
            if (target === 0 && N > 0) {
              rootMidi += 1;
              newInts[0] -= 1;
              newInts[N-1] += 1;
            } else if (target > 0) {
              newInts[target - 1] += 1;
              newInts[target] -= 1;
            }
          } else if (type === "torke-down") {
            let target = N - ((s - 1) % N) - 1;
            if (target === 0 && N > 0) {
              rootMidi -= 1;
              newInts[0] += 1;
              newInts[N-1] -= 1;
            } else if (target > 0) {
              newInts[target - 1] -= 1;
              newInts[target] += 1;
            }
          } else if (type === "expand") {
            for(let i=0; i<N; i++) newInts[i] += 1;
          } else if (type === "contract") {
            for(let i=0; i<N; i++) newInts[i] -= 1;
          } else if (type === "transpose-up") {
            rootMidi += 1;
          } else if (type === "transpose-down") {
            rootMidi -= 1;
          } else if (type === "rotate") {
            newInts = [...newInts.slice(1), newInts[0]];
          } else if (type === "invert") {
            newInts = newInts.map(x => -x);
          } else if (type === "retrograde") {
            newInts = [...newInts].reverse();
          }
        }
        return { root: midiToOMN(rootMidi), ints: newInts };
      }

      function addPitchLayer() {
        const stack = document.getElementById('pitchStack');
        const first = stack.querySelector('.pitch-layer-select');
        const clone = first.cloneNode(true);
        clone.value = "none";
        stack.appendChild(clone);
      }
      function removePitchLayer() {
        const stack = document.getElementById('pitchStack');
        if(stack.children.length > 1) {
          stack.removeChild(stack.lastElementChild);
        }
      }

      function applyPitchProcessStack(baseInts, baseRoot, steps) {
        const layers = Array.from(document.querySelectorAll('.pitch-layer-select')).map(s => s.value);
        let currentInts = [...baseInts];
        let currentRoot = baseRoot;
        let reversePitches = false;

        for (let type of layers) {
          if (type === "retrograde-sequence" && steps % 2 === 1) {
            reversePitches = !reversePitches;
          } else if (type === "invert" && steps % 2 === 1) {
             const N = currentInts.length;
             if (N > 0) {
               const topGap = currentInts.reduce((sum, curr) => sum + curr, 0);
               const rm = noteToMidi(currentRoot);
               currentRoot = midiToOMN(rm + topGap);
               currentInts = currentInts.map(x => -x).reverse();
             }
          } else if (type === "retrograde" && steps % 2 === 1) {
             currentInts = [...currentInts].reverse();
          } else if (type !== "invert" && type !== "retrograde" && type !== "retrograde-sequence") {
            const res = applyPitchProcess(currentInts, currentRoot, type, steps);
            currentInts = res.ints;
            currentRoot = res.root;
          }
        }
        return { root: currentRoot, ints: currentInts, reversePitches };
      }

      // ══════════════════════════════════════════
      // STORE / SEQUENCE
      // ══════════════════════════════════════════
      const PALETTE = [
        "#5ccbb6", "#b58fda", "#58a6ff", "#ff7b72", "#56d364", 
        "#ffb86c", "#ff79c6", "#8be9fd", "#f1fa8c"
      ];
      let colorIdx = 0;
      function getNextColor() {
        return PALETTE[colorIdx++ % PALETTE.length];
      }

      function storeBlock(overrideBarObj, overrideName, overrideColor) {
        const barObj = overrideBarObj || bars[currentBar];
        const { lengths, pitches: pl } = buildOMNForBar(barObj);

        blocks.push({
          name: overrideName || "B" + blockCounter++,
          cells: [...barObj.cells],
          extended: barObj.extended,
          intervals: [...intervals],
          root: rootNote,
          lengths: lengths,
          pitchList: pl,
          color: overrideColor || getNextColor()
        });
        renderAll();
        flash((overrideName || "Block") + " stored");
      }

      function loadBlock(i) {
        const b = blocks[i];
        bars[currentBar].cells = [...b.cells];
        bars[currentBar].extended = b.extended;
        intervals = [...b.intervals];
        rootNote = b.root;
        document.getElementById("rootNote").value = rootNote;
        syncLenInput();
        renderAll();
        flash("Loaded " + b.name);
      }

      function deleteBlock(i) {
        blocks.splice(i, 1);
        sequence = sequence
          .filter((s) => s !== i)
          .map((s) => (s > i ? s - 1 : s));
        renderAll();
      }

      function addToSequence(blockIdx) {
        sequence.push(blockIdx);
        renderAll();
        flash(blocks[blockIdx].name + " → sequence");
      }

      function removeFromSequence(pos) {
        sequence.splice(pos, 1);
        renderAll();
      }
      function clearSequence() {
        sequence = [];
        renderAll();
      }
      function clearBlocks() {
        if(confirm("Are you sure you want to clear the entire block library?")) {
          blocks = [];
          sequence = [];
          blockCounter = 1;
          renderAll();
        }
      }

      // ══════════════════════════════════════════
      // ADDITIVE/SUBTRACTIVE — REICH
      // ══════════════════════════════════════════
      function getGlassStart(len) {
        const mode = document.getElementById("glassStart").value;
        if (mode === "full") return new Array(len).fill(1);
        if (mode === "empty") return new Array(len).fill(0);
        if (mode === "single") {
          const a = new Array(len).fill(0);
          a[0] = 1;
          return a;
        }
        return [...bars[currentBar].cells.slice(0, len)];
      }

      function glassModify(cells, dir, pos) {
        const c = [...cells];
        const len = c.length;
        const indices = [];
        // collect indices matching the toggle target
        if (dir === "add") {
          // find first 0
          if (pos === "end")
            for (let i = len - 1; i >= 0; i--) {
              if (c[i] === 0) {
                indices.push(i);
                break;
              }
            }
          else if (pos === "start")
            for (let i = 0; i < len; i++) {
              if (c[i] === 0) {
                indices.push(i);
                break;
              }
            }
          else if (pos === "mid") {
            const mid = Math.floor(len / 2);
            let best = -1,
              bestD = 999;
            for (let i = 0; i < len; i++) {
              if (c[i] === 0 && Math.abs(i - mid) < bestD) {
                bestD = Math.abs(i - mid);
                best = i;
              }
            }
            if (best >= 0) indices.push(best);
          } else {
            // alt
            for (let i = 0; i < len; i++) {
              if (c[i] === 0) {
                indices.push(i);
                break;
              }
            }
          }
          indices.forEach((i) => {
            c[i] = 1;
          });
        } else {
          // find first 1
          if (pos === "end")
            for (let i = len - 1; i >= 0; i--) {
              if (c[i] === 1) {
                indices.push(i);
                break;
              }
            }
          else if (pos === "start")
            for (let i = 0; i < len; i++) {
              if (c[i] === 1) {
                indices.push(i);
                break;
              }
            }
          else if (pos === "mid") {
            const mid = Math.floor(len / 2);
            let best = -1,
              bestD = 999;
            for (let i = 0; i < len; i++) {
              if (c[i] === 1 && Math.abs(i - mid) < bestD) {
                bestD = Math.abs(i - mid);
                best = i;
              }
            }
            if (best >= 0) indices.push(best);
          } else {
            for (let i = len - 1; i >= 0; i--) {
              if (c[i] === 1) {
                indices.push(i);
                break;
              }
            }
          }
          indices.forEach((i) => {
            c[i] = 0;
          });
        }
        return c;
      }

      function generateGlass() {
        const dir = document.getElementById("glassDir").value;
        const pos = document.getElementById("glassPos").value;
        const reps = Math.max(
          1,
          parseInt(document.getElementById("glassReps").value) || 2,
        );
        const len = bars[currentBar].cells.length;
        const extended = bars[currentBar].extended;

        // build phases
        const phases = [];
        const makePhase = (startCells, direction) => {
          let current = [...startCells];
          const notes = current.filter((x) => x).length;
          const steps = direction === "add" ? len - notes : notes;
          for (let s = 0; s <= steps; s++) {
            for (let r = 0; r < reps; r++) phases.push([...current]);
            if (s < steps) current = glassModify(current, direction, pos);
          }
        };

        const start = getGlassStart(len);
        if (dir === "add") makePhase(start, "add");
        else if (dir === "sub") makePhase(start, "sub");
        else if (dir === "add-sub") {
          makePhase(start, "add");
          makePhase(new Array(len).fill(1), "sub");
        } else {
          makePhase(start, "sub");
          makePhase(new Array(len).fill(0), "add");
        }

        const prefix = "A" + blockCounter;
        const autoSeq = document.getElementById("autoAddSeqOverlay") && document.getElementById("autoAddSeqOverlay").checked;
        phases.forEach((cells, i) => {
          const { root: pRoot, ints: pInts, reversePitches } = applyPitchProcessStack(intervals, rootNote, i);
          const barObj = { cells, extended };
          const name = prefix + "." + (i + 1);
          const { lengths, pitches: pl } = buildOMNForBar(barObj, pRoot, pInts, reversePitches);
          
          blocks.push({
            name,
            cells: [...cells],
            extended,
            intervals: [...pInts],
            root: pRoot,
            lengths,
            pitchList: pl,
            color: getNextColor()
          });
          if (autoSeq) sequence.push(blocks.length - 1);
        });
        blockCounter++;
        renderAll();
        flash(
          "Generated " +
            phases.length +
            " Additive blocks (A" +
            (blockCounter - 1) +
            ")",
        );
        document.getElementById("glassPreview").textContent =
          "→ " + phases.length + " blocks generated. Add to sequence.";
      }

      // ══════════════════════════════════════════
      // ADDITIVE/SUBTRACTIVE — GLASS
      // ══════════════════════════════════════════
      function getReichPattern(len) {
        const mode = document.getElementById("reichFill").value;
        if (mode === "all") return new Array(len).fill(1);
        if (mode === "alt")
          return Array.from({ length: len }, (_, i) => (i % 2 === 0 ? 1 : 0));
        // 'current': tile the current bar pattern
        const src = bars[currentBar].cells;
        return Array.from({ length: len }, (_, i) => src[i % src.length]);
      }

      function generateReich() {
        const dir = document.getElementById("reichDir").value;
        const startLen = Math.max(
          1,
          parseInt(document.getElementById("reichStart").value) || 4,
        );
        const endLen = Math.max(
          1,
          parseInt(document.getElementById("reichEnd").value) || 16,
        );
        const step = Math.max(
          1,
          parseInt(document.getElementById("reichStep").value) || 1,
        );
        const reps = Math.max(
          1,
          parseInt(document.getElementById("reichReps").value) || 2,
        );
        const extended = bars[currentBar].extended;

        const phases = [];
        const makeLengths = (from, to) => {
          const lengths = [];
          if (from <= to) {
            for (let l = from; l <= to; l += step) lengths.push(l);
          } else {
            for (let l = from; l >= to; l -= step) lengths.push(l);
          }
          return lengths;
        };

        let lens = [];
        if (dir === "add") lens = makeLengths(startLen, endLen);
        else if (dir === "sub") lens = makeLengths(endLen, startLen);
        else if (dir === "add-sub")
          lens = [
            ...makeLengths(startLen, endLen),
            ...makeLengths(endLen - step, startLen),
          ];
        else
          lens = [
            ...makeLengths(endLen, startLen),
            ...makeLengths(startLen + step, endLen),
          ];

        lens.forEach((len) => {
          const cells = getReichPattern(len);
          for (let r = 0; r < reps; r++) phases.push([...cells]);
        });

        const prefix = "BA" + blockCounter;
        const autoSeq = document.getElementById("autoAddSeqOverlay") && document.getElementById("autoAddSeqOverlay").checked;
        phases.forEach((cells, i) => {
          const { root: pRoot, ints: pInts, reversePitches } = applyPitchProcessStack(intervals, rootNote, i);
          const barObj = { cells, extended };
          const name = prefix + "." + (i + 1);
          const { lengths, pitches: pl } = buildOMNForBar(barObj, pRoot, pInts, reversePitches);
          
          blocks.push({
            name,
            cells: [...cells],
            extended,
            intervals: [...pInts],
            root: pRoot,
            lengths,
            pitchList: pl,
            color: getNextColor()
          });
          if (autoSeq) sequence.push(blocks.length - 1);
        });
        blockCounter++;
        renderAll();
        flash(
          "Generated " +
            phases.length +
            " Block Additive blocks (BA" +
            (blockCounter - 1) +
            ")",
        );
        document.getElementById("reichPreview").textContent =
          "→ " + phases.length + " blocks: lengths " + lens.join(" → ");
      }

      // ══════════════════════════════════════════
      // ADDITIVE/SUBTRACTIVE — PHASE
      // ══════════════════════════════════════════
      function generatePhase() {
        const start = Math.max(0, parseInt(document.getElementById("phaseStart").value) || 0);
        const end = Math.max(start, parseInt(document.getElementById("phaseEnd").value) || 15);
        const dir = document.getElementById("phaseDir").value;
        const step = Math.max(1, parseInt(document.getElementById("phaseStep").value) || 1);
        const total = Math.max(1, parseInt(document.getElementById("phaseTotal").value) || 8);
        const extended = bars[currentBar].extended;
        
        const baseCells = bars[currentBar].cells;
        const len = baseCells.length;
        
        const phases = [];
        for(let i=0; i<total; i++) {
          let c = [...baseCells];
          let shiftPx = i * step;
          let sub = c.slice(start, end+1);
          let slen = sub.length;
          
          if (dir === 'right') {
            const r = ((shiftPx % slen) + slen) % slen;
            sub = [...sub.slice(slen - r), ...sub.slice(0, slen - r)];
          } else {
            const r = ((shiftPx % slen) + slen) % slen;
            sub = [...sub.slice(r), ...sub.slice(0, r)];
          }
          
          for(let j=0; j<slen; j++) {
            if(start+j < len) c[start+j] = sub[j];
          }
          phases.push(c);
        }

        const prefix = "P" + blockCounter;
        const autoSeq = document.getElementById("autoAddSeqOverlay") && document.getElementById("autoAddSeqOverlay").checked;
        phases.forEach((cells, i) => {
          const { root: pRoot, ints: pInts, reversePitches } = applyPitchProcessStack(intervals, rootNote, i);
          const barObj = { cells, extended };
          const name = prefix + "." + (i + 1);
          const { lengths, pitches: pl } = buildOMNForBar(barObj, pRoot, pInts, reversePitches);
          
          blocks.push({
            name,
            cells: [...cells],
            extended,
            intervals: [...pInts],
            root: pRoot,
            lengths,
            pitchList: pl,
            color: getNextColor()
          });
          if (autoSeq) sequence.push(blocks.length - 1);
        });
        
        blockCounter++;
        renderAll();
        flash("Generated " + phases.length + " Phase blocks (P" + (blockCounter - 1) + ")");
        document.getElementById("phasePreview").textContent = "→ " + phases.length + " blocks generated.";
      }

      // ══════════════════════════════════════════
      // CONFIGURATION SAVE/LOAD
      // ══════════════════════════════════════════
      function saveConfig() {
        const data = {
          bars, currentBar, intervals, rootNote, blocks, sequence, blockCounter,
          tempo: document.getElementById('tempoSlider').value,
          waveform: document.getElementById('waveform').value,
          loopToggle: document.getElementById('loopToggle').checked,
          seqLoopToggle: document.getElementById('seqLoopToggle').checked,
        };
        const json = JSON.stringify(data);
        const blob = new Blob([json], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "omn_workbench_config.json";
        a.click();
        URL.revokeObjectURL(url);
        flash("Config downloaded");
      }

      function loadConfig() {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = "application/json";
        input.onchange = (e) => {
          const file = e.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (re) => {
            try {
              const data = JSON.parse(re.target.result);
              if (data.bars) bars = data.bars;
              if (data.currentBar !== undefined) currentBar = data.currentBar;
              if (data.intervals) intervals = data.intervals;
              if (data.rootNote) rootNote = data.rootNote;
              if (data.blocks) blocks = data.blocks;
              if (data.sequence) sequence = data.sequence;
              if (data.blockCounter) blockCounter = data.blockCounter;
              if (data.tempo) {
                document.getElementById('tempoSlider').value = data.tempo;
                document.getElementById('tempoVal').textContent = data.tempo + " ♩";
              }
              if (data.waveform) document.getElementById('waveform').value = data.waveform;
              if (data.loopToggle !== undefined) document.getElementById('loopToggle').checked = data.loopToggle;
              if (data.seqLoopToggle !== undefined) document.getElementById('seqLoopToggle').checked = data.seqLoopToggle;
              document.getElementById('rootNote').value = rootNote;
              syncLenInput();
              renderAll();
              flash("Config loaded");
            } catch (err) {
              alert("Error parsing config file");
            }
          };
          reader.readAsText(file);
        };
        input.click();
      }

      // ══════════════════════════════════════════
      // COPY
      // ══════════════════════════════════════════
      function copyOMN() {
        navigator.clipboard.writeText(
          document.getElementById("omnOutput").textContent,
        );
        flash("Copied");
      }
      function copyFullSequence() {
        navigator.clipboard.writeText(
          document.getElementById("sequenceOMN").textContent,
        );
        flash("Full sequence copied");
      }
      function flash(msg) {
        const el = document.getElementById("statusFlash");
        el.textContent = msg;
        el.classList.add("show");
        setTimeout(() => el.classList.remove("show"), 1800);
      }

      // ══════════════════════════════════════════
      // PLAYBACK
      // ══════════════════════════════════════════
      function getAudioCtx() {
        if (!audioCtx)
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        return audioCtx;
      }

      function stopPlayback() {
        if (playbackTimeout) {
          clearTimeout(playbackTimeout);
          playbackTimeout = null;
        }
        isPlaying = false;
        document.getElementById("playBtn").classList.remove("playing");
        document.getElementById("playBtn").textContent = "▶";
        document.getElementById("playSeqBtn").classList.remove("playing");
        renderGrid(-1);
        highlightSequenceSlot(-1);
      }

      // Play a barObj with audio. Respects extended notes for duration.
      function scheduleBarAudio(
        ctx,
        time,
        barObj,
        pitchRoot,
        pitchInts,
        tempo,
      ) {
        const waveform = document.getElementById("waveform").value;
        const secsPerSixteenth = 60 / tempo / 4;
        const pitches = generatePitches(
          pitchRoot,
          pitchInts,
          barObj.cells.length + 4,
        );

        const tokens = binaryToLengthTokens(barObj.cells, barObj.extended);
        let pitchIdx = 0;
        let t = time;

        // parse duration token to seconds
        function tokenDurToSecs(dur) {
          const clean = dur.replace(/^-/, "");
          const frac = {
            s: 1,
            e: 2,
            "e.": 3,
            q: 4,
            "q.": 5,
            h: 8,
            "h.": 12,
            w: 16,
          };
          if (frac[clean] !== undefined) return frac[clean] * secsPerSixteenth;
          const m = clean.match(/^(\d+)\/16$/);
          if (m) return parseInt(m[1]) * secsPerSixteenth;
          const m2 = clean.match(/^(\d+)\/(\d+)$/);
          if (m2)
            return (parseInt(m2[1]) / parseInt(m2[2])) * 4 * secsPerSixteenth;
          return secsPerSixteenth;
        }

        tokens.forEach((tok) => {
          const durSecs = tokenDurToSecs(tok.dur);
          if (!tok.isRest) {
            const freq = midiToHz(pitches[pitchIdx++ % pitches.length]);
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.type = waveform;
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(0.0001, t);
            gain.gain.exponentialRampToValueAtTime(0.17, t + 0.01);
            gain.gain.exponentialRampToValueAtTime(0.001, t + durSecs * 0.88);
            osc.start(t);
            osc.stop(t + durSecs);
          }
          t += durSecs;
        });

        return t - time; // return precise duration
      }

      let nextPlayTime = 0;
      let playingSequence = false;
      let seqPos = 0;
      // We store UI timeouts so we can cancel them
      let uiTimeouts = [];

      function clearUiTimeouts() {
        uiTimeouts.forEach((t) => clearTimeout(t));
        uiTimeouts = [];
      }

      document.getElementById("playBtn").onclick = function () {
        if (isPlaying && !playingSequence) {
          stopPlayback();
          clearUiTimeouts();
          return;
        }
        stopPlayback();
        clearUiTimeouts();
        isPlaying = true;
        playingSequence = false;
        this.classList.add("playing");
        this.textContent = "■";

        const ctx = getAudioCtx();
        if (ctx.state === "suspended") ctx.resume();

        // start scheduling slightly in the future
        nextPlayTime = ctx.currentTime + 0.05;

        function scheduler() {
          if (!isPlaying || playingSequence) return;

          const lookahead = 0.1;
          while (nextPlayTime < ctx.currentTime + lookahead) {
            const tempo = parseInt(
              document.getElementById("tempoSlider").value,
            );
            const barObj = bars[currentBar];
            const duration = scheduleBarAudio(
              ctx,
              nextPlayTime,
              barObj,
              rootNote,
              intervals,
              tempo,
            );

            const secsPerSixteenth = 60 / tempo / 4;
            for (let i = 0; i < barObj.cells.length; i++) {
              const uiTime =
                nextPlayTime + i * secsPerSixteenth - ctx.currentTime;
              if (uiTime > 0) {
                uiTimeouts.push(
                  setTimeout(() => {
                    if (isPlaying && !playingSequence) renderGrid(i);
                  }, uiTime * 1000),
                );
              }
            }

            nextPlayTime += duration;

            if (!document.getElementById("loopToggle").checked) {
              uiTimeouts.push(
                setTimeout(
                  () => {
                    stopPlayback();
                    clearUiTimeouts();
                  },
                  (nextPlayTime - ctx.currentTime) * 1000,
                ),
              );
              return;
            }
          }
          playbackTimeout = setTimeout(scheduler, 25);
        }

        scheduler();
      };

      document.getElementById("playSeqBtn").onclick = function () {
        if (isPlaying && playingSequence) {
          stopPlayback();
          clearUiTimeouts();
          return;
        }
        if (sequence.length === 0) {
          flash("No sequence");
          return;
        }

        stopPlayback();
        clearUiTimeouts();
        isPlaying = true;
        playingSequence = true;
        this.classList.add("playing");

        const ctx = getAudioCtx();
        if (ctx.state === "suspended") ctx.resume();

        nextPlayTime = ctx.currentTime + 0.05;
        seqPos = 0;

        function scheduler() {
          if (!isPlaying || !playingSequence) return;

          const lookahead = 0.1;
          while (nextPlayTime < ctx.currentTime + lookahead) {
            if (seqPos >= sequence.length) {
              if (document.getElementById("seqLoopToggle").checked) {
                seqPos = 0;
              } else {
                uiTimeouts.push(
                  setTimeout(
                    () => {
                      stopPlayback();
                      clearUiTimeouts();
                    },
                    (nextPlayTime - ctx.currentTime) * 1000,
                  ),
                );
                return;
              }
            }

            const b = blocks[sequence[seqPos]];
            const barObj = { cells: b.cells, extended: b.extended };
            const tempo = parseInt(
              document.getElementById("tempoSlider").value,
            );

            const currentSeqPos = seqPos;
            const uiTime = nextPlayTime - ctx.currentTime;
            
            if (uiTime > 0) {
              uiTimeouts.push(
                setTimeout(() => {
                  if (isPlaying && playingSequence) highlightSequenceSlot(currentSeqPos);
                }, uiTime * 1000)
              );
            } else if (isPlaying && playingSequence) {
              highlightSequenceSlot(currentSeqPos);
            }

            const duration = scheduleBarAudio(
              ctx,
              nextPlayTime,
              barObj,
              b.root,
              b.intervals,
              tempo,
            );
            nextPlayTime += duration;
            seqPos++;
          }
          playbackTimeout = setTimeout(scheduler, 25);
        }
        scheduler();
      };

      document.getElementById("tempoSlider").oninput = function () {
        document.getElementById("tempoVal").textContent = this.value + " ♩";
      };

      document.addEventListener('keydown', function(e) {
        if (e.code === 'Space' && e.target === document.body) {
          e.preventDefault();
          document.getElementById('playBtn').click();
        }
      });

      // ══════════════════════════════════════════
      // INIT
      // ══════════════════════════════════════════
      syncLenInput();
      renderAll();
    </script>
  </body>
</html>
