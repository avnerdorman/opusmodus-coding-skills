Opusmodus                                                               interference-square    1

interference-square sequence
[Function]

Arguments and Values:
sequence                  an integer list.


Description:

Method 2

Example of (3 2) interference rhythm.

(3 2) = (1) (1) (1) (1) (1) (1) (1) (1) (1) -> total length
3 (3) = (1   1   1) (1   1   1) (1   1   1) -> (3 3 3)
3 (2) = (1   1) (1   1) (1   1)             -> (2 2 2)
3 (2) =             (1   1) (1   1) (1   1) -> (2 2 2)
result= (1   1) (1) (1) (1) (1) (1) (1   1) -> (2 1 1 1 1 1 2)

In this second method the larger number (pulse) in the ratio (3) is squared (3*3) to provide
the total length and the number of repetitions of that pulse (3+3+3). The number of
repetitions of the smaller pulse (2) is multiplied by the larger (3) in order to give the number
of repetitions. However, note that (2+2+2) does not complete the cycle of 9 beats as was the
case in method 1. It is necessary to repeat the smaller pulse group (2+2+2) but starting not at
the beginning but at the second appearance of the larger pulse.

All rhythms generated by this method are repetitive. Each complete cycle is symmetrical
around its centre '(2 1 1 2). Schillinger suggests that symmetrical rhythms have
important musical qualities: economy, since one half generates the other, balance due to the
mirror symmetry and a quality Schillinger refers to as contrast, the difference between
successive numbers. The greater the difference between numbers the greater the contrast.

Note that the ratio is underlined in order to visually distinguish from Method 1.

(interference-square '(4 3))
=> (3 1 2 1 1 1 1 2 1 3)

(interference-square '(5 3))
=> (3 2 1 2 1 1 1 1 1 1 1 1 1 2 1 2 3)
Opusmodus                                                             interference-square   2

Examples:

One way of using the interference square is to call a rhythmic group as an integer.

(setf isquare (interference-square '(4 3)))
=> (3 1 2 1 1 1 1 2 1 3)

(setf 3x '(c4 cs4 d4) ; congas
      2x '(cs4 ds4)
      1x '(d4))

(setf perc-solo
      (assemble-seq
       (gen-repeat2 isquare (list 3x 1x 2x 1x 1x 1x 1x 2x 1x 3x))))
=> ((c4 cs4 d4) (c4 cs4 d4) (c4 cs4 d4) (d4) (cs4 ds4) (cs4 ds4)
    (d4) (d4) (d4) (d4) (cs4 ds4) (cs4 ds4) (d4) (c4 cs4 d4)
    (c4 cs4 d4) (c4 cs4 d4))

(setf perc-rhy (gen-tuplet 1 1 'm '? 'q (mclength perc-solo)))
=> ((1/12 1/12 1/12) (1/12 1/12 1/12) (1/12 1/12 1/12) (1/4) (1/8 1/8)
    (1/8 1/8) (1/4) (1/4) (1/4) (1/4) (1/8 1/8) (1/8 1/8) (1/4)
    (1/12 1/12 1/12) (1/12 1/12 1/12) (1/12 1/12 1/12))
